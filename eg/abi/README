#    SPDX-FileCopyrightText: 2021 Monaco F. J. <monaco@usp.br>
#   
#    SPDX-License-Identifier: GPL-3.0-or-later
#
#    This file was generated by SYSeg from a corresponding m4 script.
#    SYSeg is available at https://gitlab.com/monaco/syseg.

 

##
##  NOTE: The contents of this directory are being reviewed for assessment
##        and potential revision of source code and documentation.
##
##  -----------------------------------------------------------------------



 Application binary interface
 ==============================

 This directory contains a series of source code files illustrating different
 aspects of the x86 application binary interface and related concepts. It
 includes examples of data alignment, name mangling, syscall interface,
 calling convention, among others.

 Contents
 ------------------------------

 * eg-00.c		Simple source code to exemplify program sections.

   			   make eg-01.o/a*
			   

			Notice sections

			   .text	code (instructions)
			   .data	initialized global variables
			   .bss 	uninitalized global variables


			Try and compare

			   readelf -S eg-00.o

			   readelf -S eg-00

			   
 * eg-01.c		An example to illustrate how variables are allocated.

   			Try

			    make eg-01.o/a*
			    make eg-01/a*

 * eg-02.c		Memory aliment.

   			    make eg-02.o/d*

   			See that struct foo_t occupies 4 rather than 5 bytes.

                            make eg-02/d*

			See that even the .text segment has padding zeroes.

 * eg-02_pack.c		Forced packing.

   			    make eg-02_pack.o/d*

			See that now struct foo_t occupies 5 bytes.

 * eg-03_beta.asm	A minimal asm program which makes a syscall.



 * eg-03.asm		A minimal program that invokes a system call in Linux, x86.

   			Issuing int 0x80 directly.

			Syscall 1 is 'exit' (as it currently stands for
			x86 Linux). On the kernel side, the syscall reads
			eax, and pass its value as a 8-bit return status
			code to the parent process. We can inspect this value
			in variable $? at the shell prompt.

			   make eg-03
			   ./eg-03
			   echo $?

   			Entry point is defined through linker argument.

			   readelf -s eg-03_beta       (for symbol table)
			   readelf -h eg-03_beta       (for elf header)


 * eg-03_c.c		OS and C runtime ABIs.

   			Binary entry point defined by _start (.syntab).

			C entry point called by _start.

 * eg-03_c2.c		C Runtime initialization (crt0).

   			Runtime initilizer is prepended by compiler.

 * eg-04.c		Like eg-03.asm, but written in C.

   			Program calls syscall number 4: write.

 * eg-04_64.c		Like eg-04.c, but for x86_06.

   			Notice that the system call is the same, but 'write'
			now is number 1. Calling syscalls via their numbers
			is not portable.

 * eg-05.c		Call syscall via libc.

   			Rather than invoking the system call directly, we now
			use the runtime C library. Function 'write' performs the
			corresponding syscall using the appropriate parameters.

			   make eg-05       will build x86 version
			   make eg-05_64    will build x86_64 version

			both should work now, because the program will be linked
			against the appropriate implementation of 'write'.

 * eg-06.asm		A call to a void function.

   			Callee returns a value via register eax.

			make eg-06

 * eg-07.c		A C equivalent or eg-06, in x86 Linux.

   			An opportunity to recall the crt0 (c-runtime-zero) appended
			by the linker to provide a C runtime.

			make CFLAGS=-O1 eg-06

 * eg-08.asm		Calling convention: passing arguments via global variables.

 * eg-09.asm		Fastcall calling convention: passing via registers.

 * eg-10.asm		Passing paramter via stack (part I)

 * eg-11.asm 
 


 APPENDEX I
 -----------------------------
 


 Bintools: convenience rules for inspecting binary files
 ------------------------------------------------------------
 
 SYSeg's Bintools is a collection of Makefile rules aimed as shortcut for
 invoking binary inspection utilities. It contains handy Make rules for
 disassembling objects, comparing files, creating bootable images, invoking
 platform emulators and other facilities. Some shortcuts are ad hoc rules
 crafted under poetic license and may depart from conventional Make usage.

 CONVENTIONS
 
 As a rule of thumb, a file named

     foo.bar            contains the working implementation
     foo-beta.bar	contains working but cumbersome/inelegant implementation
     foo-alpha.bar	contains incomplete or wrong implementation

 File extensions:

   -`hex`  ASCII file containing values in hexadecimal representation;

   -`asm`  manually written assembly code in Intel ASM format;

   -`S`    manually written assembly code in AT&T Gas format;

   -`s`    assembly code in AT&T Gas format generated by the compiler (gcc);

   -`o`    object code produced by the assembler;

   -`i`    pre-processed source code generated by the pre-processor (CPP)

   -`bin`  flat-binary file generated by the linker;

   -`iso`  ISO9660 (ECMA-119) file system intended for optical disk media (CD) 

   -`ld`   linker script (ld).


 Some examples allow alternative build recipes which can be selected
 by passing the command-line variable 'ALT=<number>' to 'make'. See bellow.

 NEEDED SOFTWARE

 In order to experiment with the examples in this section, the following
 pieces of software may be needed. The list indicates the lowest versions
 against which the project has been tested. Using a more recent version should
 be ok, but it is not absolutely guaranteed that results won't exhibit minor
 variations. Feedback is always appreciated.

 If required for a particular example, it is safe to use

 - Linux         5.13.0         (any decent ditribution)
 - gcc 	     	 9.3.0	        (the GNU compiler)
 - GNU binutils  2.34		(GNU assembler, linker, disassembler etc.) 
 - nasm		 2.14.02	(NASM assembler)
 - qemu		 4.2.1		(most probably qemu-system-i386)
 - gcc-multilib  9.3.0		(to compile 32-bit code in a 64-bit platform)
 - xorriso	 1.5.2-1	(depending on your computer's BIOS)
 - hexdump	 POSIX.2	(binary editor)
 
 CONVENIENCE RULES 


 * For building and inspecting binaries, use

   make					     Build the default target.

   make foo				     Build foo.

   make diss IMG=foo 			     Disassemble foo.

   	     	     			     Optionally,

					        ASM  = intel | att  (default)
						BIT  =    16 | 32   (default)

   make dump IMG=foo			     Show the raw contents of foo.
   
   make      			             Build everything (or make all)

   make clean			             Undo make all

   make diff foo bar baz		     Show graphical diff between files

   	     	     			     ASM and BIT variables apply


  * If any example involves the manipulation of a bootable image, use
  

   make run IMG=foo	             	     Run foo in the emulator

   make stick IMG=foo DEVICE=/dev/sdX        make a bootable USB stick


   SHORTCUTS

   For further convenience, the build script offers some ad hoc shortcuts:
   

   make foo/diss | foo/d		     disassemble .text as 32-bit AT&T

   make foo/diss intel|att		     disassemble as 32-bit Intel or AT&T
   make foo/diss 16|32			     disassemble as 16-bit or 32-bit
   make foo/diss intel|att 16|32	     disassemble as Intel|AT&T 16|32 bit
   make foo/diss 16|32 intel|att	     disassemble as Intel|AT&T 16|32 bit

   make foo/i16	       			     disassemble as Intel 16-bit
   make foo/a16 | foo/16  		     disassemble as AT&T  16-bit
   make foo/a32	| foo/32 | foo/a     	     disassemble as AT&T  32-bit
   make foo/i32	         | foo/i	     disassemble as Intel 32-bit

   		   			     In all disassembly rules, a
					     trailing '*' means disassemble all
					     sections, e.g. foo/d* foo/16* ...

   make foo/hex | foo/raw | foo/dump	     show raw contents in hexadecimal

   make foo/run				     test foo (mbr) with the emulator
   make foo/fd				     test foo (floppy) with the emulator

   make diffi16 | di16 | i16 foo bar baz     make diff with ASM=intel BIT=16
   make diffi32 | di32 | i32 foo bar baz     make diff with ASM=intel BIT=32
   make diffa16 | da16 | a16 foo bar baz     make diff with ASM=att BIT=16
   make diffa32 | da32 | a32 foo bar baz     make diff with ASM=att BIT=32

   make foo/stick dev    	   	     make stick IMG=foo DEVICE=dev

   make foo/l	  			     open foo in 'less' program

 

