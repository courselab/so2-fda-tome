#    SPDX-FileCopyrightText: 2021 Monaco F. J. <monaco@usp.br>
#   
#    SPDX-License-Identifier: GPL-3.0-or-later
#
#    This file was generated by SYSeg from a corresponding m4 script.
#    SYSeg is available at https://gitlab.com/monaco/syseg.

##
##  NOTE: The contents of this directory are being reviewed for assessment
##        and potential revision of source code and documentation.
##
##  -----------------------------------------------------------------------



 Application binary interface
 ==============================

 This directory contains a series of source code files illustrating 
 the POSIX mechanism of process execution, with examples of usage
 of fork, exec and wait functions.

 Contents
 ------------------------------

 * eg-01.c		Simple fork & wait example.

   			Parent finishes first and waits for child.
			Child's exit status is collected by parent.

			Execute and observe.

			Also run

			   ps -p $$ -o tty=

			and in a different terminal, run

			   make TERM=<term> ps

			where <term> is the output of the previos command.

 * eg-02.c		Simple example of exec.

   			If argv1 is large enough, program calls exec and replace
			its image iwth eg-02_aux.

			Execute and observe.

 * eg-03.c		Fork, exec, wait: the bare bones of a command-line shell.

   			Program reads a program name from the terminal prompt and execute it.

			No support for command-line arguments; no built-in commands.

 * eg-04.c		A small program to illustrate static linking.

  			Compare

  			  make eg-04.o/a
			  make eg-04/a

			and see that the variable's and the function's addresses are
			unresolved. Later on, the linker checks the object's relocation
			section

			  readelf -r eg-04.o

			and detect that the address of the variable should be replaced
			at the indicated offset. Then, in the binary (linked) program,
			the pending symbols are resolved.


			Also, run the program within GDB, set a break point at main(),
			execute the program and disassemble it

			  gdb eg-04
			  break main
			  run
			  disassemble

		 	See that the variable address is now different. This is the
			location in RAM where the variable landed when the OS loaded
			the program.


* eg-05.c	A small program to illustrate reolocation and PIC.

  			
   		This example is simular to eg-04. The program eg-05 calls a
		function defined in a different translation unity eg-05-aux.c

		In the first verion, eg-05-aux.c is converted into the object
		format, and then converted into a static library.  Subsequently,
		the library is linked against eg-05.o to produce the binary
		eg-05-rel.

		We called it '-rel' to highlight the fact that the library
		function's address will relocated during load time.

		We can see the relocation information passed to the loader

		   readelf -r eg-05-rel

		Now, build eg-05-pic

		   make eg-05-pic

               Unlike eg-05-rel, linked against libeg-05-rel.so, this
	       version of the program is liked against libeg-05-pic.so.

	           The difference is produced by the gcc option -fpic and
		   -fno-pic used to produce the objects eg-05-rel.o and
		   eg-05-pic.o.

		Rather than load-time relocation, position-independent code
		(PIC) relies on run-time relocation. It's the program itself
		that computes the symbol address while in execution.

		Compare

		   readelf -r eg-05-rel
		   readelf -r eg-05-pic

		and see that the symbol bar is listed, respective, in the
		dynamic relocation section (load-time), and in the procedure
		linkage table (PLT).

		TODO: explain how PLD and Got work.

		



			
 APPENDEX I
 -----------------------------
 


 Bintools: convenience rules for inspecting binary files
 ------------------------------------------------------------
 
 SYSeg's Bintools is a collection of Makefile rules aimed as shortcut for
 invoking binary inspection utilities. It contains handy Make rules for
 disassembling objects, comparing files, creating bootable images, invoking
 platform emulators and other facilities. Some shortcuts are ad hoc rules
 crafted under poetic license and may depart from conventional Make usage.

 CONVENTIONS
 
 As a rule of thumb, a file named

     foo.bar            contains the working implementation
     foo-beta.bar	contains working but cumbersome/inelegant implementation
     foo-alpha.bar	contains incomplete or wrong implementation

 File extensions:

   -`hex`  ASCII file containing values in hexadecimal representation;

   -`asm`  manually written assembly code in Intel ASM format;

   -`S`    manually written assembly code in AT&T Gas format;

   -`s`    assembly code in AT&T Gas format generated by the compiler (gcc);

   -`o`    object code produced by the assembler;

   -`i`    pre-processed source code generated by the pre-processor (CPP)

   -`bin`  flat-binary file generated by the linker;

   -`iso`  ISO9660 (ECMA-119) file system intended for optical disk media (CD) 

   -`ld`   linker script (ld).


 Some examples allow alternative build recipes which can be selected
 by passing the command-line variable 'ALT=<number>' to 'make'. See bellow.

 NEEDED SOFTWARE

 In order to experiment with the examples in this section, the following
 pieces of software may be needed. The list indicates the lowest versions
 against which the project has been tested. Using a more recent version should
 be ok, but it is not absolutely guaranteed that results won't exhibit minor
 variations. Feedback is always appreciated.

 If required for a particular example, it is safe to use

 - Linux         5.13.0         (any decent ditribution)
 - gcc 	     	 9.3.0	        (the GNU compiler)
 - GNU binutils  2.34		(GNU assembler, linker, disassembler etc.) 
 - nasm		 2.14.02	(NASM assembler)
 - qemu		 4.2.1		(most probably qemu-system-i386)
 - gcc-multilib  9.3.0		(to compile 32-bit code in a 64-bit platform)
 - xorriso	 1.5.2-1	(depending on your computer's BIOS)
 - hexdump	 POSIX.2	(binary editor)
 
 CONVENIENCE RULES 


 * For building and inspecting binaries, use

   make					     Build the default target.

   make foo				     Build foo.

   make diss IMG=foo 			     Disassemble foo.

   	     	     			     Optionally,

					        ASM  = intel | att  (default)
						BIT  =    16 | 32   (default)

   make dump IMG=foo			     Show the raw contents of foo.
   
   make      			             Build everything (or make all)

   make clean			             Undo make all

   make diff foo bar baz		     Show graphical diff between files

   	     	     			     ASM and BIT variables apply


  * If any example involves the manipulation of a bootable image, use
  

   make run IMG=foo	             	     Run foo in the emulator

   make stick IMG=foo DEVICE=/dev/sdX        make a bootable USB stick


   SHORTCUTS

   For further convenience, the build script offers some ad hoc shortcuts:
   

   make foo/diss | foo/d		     disassemble .text as 32-bit AT&T

   make foo/diss intel|att		     disassemble as 32-bit Intel or AT&T
   make foo/diss 16|32			     disassemble as 16-bit or 32-bit
   make foo/diss intel|att 16|32	     disassemble as Intel|AT&T 16|32 bit
   make foo/diss 16|32 intel|att	     disassemble as Intel|AT&T 16|32 bit

   make foo/i16	       			     disassemble as Intel 16-bit
   make foo/a16 | foo/16  		     disassemble as AT&T  16-bit
   make foo/a32	| foo/32 | foo/a     	     disassemble as AT&T  32-bit
   make foo/i32	         | foo/i	     disassemble as Intel 32-bit

   		   			     In all disassembly rules, a
					     trailing '*' means disassemble all
					     sections, e.g. foo/d* foo/16* ...

   make foo/hex | foo/raw | foo/dump	     show raw contents in hexadecimal

   make foo/run				     test foo (mbr) with the emulator
   make foo/fd				     test foo (floppy) with the emulator

   make diffi16 | di16 | i16 foo bar baz     make diff with ASM=intel BIT=16
   make diffi32 | di32 | i32 foo bar baz     make diff with ASM=intel BIT=32
   make diffa16 | da16 | a16 foo bar baz     make diff with ASM=att BIT=16
   make diffa32 | da32 | a32 foo bar baz     make diff with ASM=att BIT=32

   make foo/stick dev    	   	     make stick IMG=foo DEVICE=dev

   make foo/l	  			     open foo in 'less' program

 

