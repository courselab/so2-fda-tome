#    SPDX-FileCopyrightText: 2021 Monaco F. J. <monaco@usp.br>
#   
#    SPDX-License-Identifier: GPL-3.0-or-later
#
#    This file was generated by SYSeg from a corresponding m4 script.
#    SYSeg is available at https://gitlab.com/monaco/syseg.

bin = mkfat12-beta mkfat12 mbrinfo fatinfo

all : $(bin)


# Update docm4 files.
#
# These rules are not relevant for the source-code examples in this directory.
# The are provided to automatically update docm4 files when their respective
# sources change. It won't have effect in an exported directory, though.

-include .dist

ifneq (yes,$(DOCM4_DIST))


docm4_deps = ../../tools/docm4.m4 ../../tools/bintools.m4

Makefile : Makefile.m4 $(docm4_deps) 
	@path=$$(pwd) ; dir=$${path##*/};\
	 make -C .. $$dir/Makefile;
	@echo "syseg>>: Makefile has changed: all targets may need to be rebuilt."
	@echo "Building" $$(test -z "$(MAKECMDGOALS)" && echo "the default target" || echo "$(MAKECMDGOALS)")
	@make -f Makefile $(MAKECMDGOALS)

docm4_supported_files = README 

$(docm4_supported_files): % : %.m4 $(docm4_deps)
	@path=$$(pwd) ; dir=$${path##*/}; make -C .. $$dir/$(*) 

updatem4: Makefile
#	@path=$$(pwd) ; dir=$${path##*/}; make -C .. $$(for i in $(docm4_supported_files); do test -f $$dir/$$i.m4 && echo "$$dir/$$i" ; done)
	@make $(docm4_supported_files)

endif

# End of update docm4 files.




## Bintools: convenience rules for inspecting binary files
##
## SYSeg's Bintools is a collection of Makefile rules for invoking
## binary-inspection utility programs. It contains handy shortcuts for
## disassembling objects, comparing files, creating bootable images, invoking
## platform emulators and other facilities. Some shortcuts are ad hoc rules
## crafted under a poetic license and may depart from conventional Make usage.

##
## Configuration
##


# Inform your preferred graphical diff tool e.g meld, kdiff3 etc.

DIFF_TOOL=meld


##
## You probably don't need to change beyond this line
##

# Disassemble

# ALT = intel | att  (default: att)

ifndef ASM
ifeq (,$(findstring intel, $(MAKECMDGOALS)))
ASM_SYNTAX = att
else
ASM_SYNTAX = intel
endif
else
ASM_SYNTAX= $(ASM)
endif

# BIT = 16 | 32  (default: 32)

ifndef BIT
ifeq (,$(findstring 16, $(MAKECMDGOALS)))
ASM_MACHINE = i386
else
ASM_MACHINE = i8086
endif
else

ifeq ($(BIT),16)
ASM_MACHINE = i8086
else
ASM_MACHINE = i386
endif

endif


intel att 16 32: 
	@echo > /dev/null

##
## Options
##

opts = $(filter .optnop, $(MAKECMDGOALS))
symbol = $(filter ..%, $(MAKECMDGOALS))

$(opts) $(symbol):
	@echo > /dev/null

objdump_nop = "cat"
objdump_disassemble = "-d"

#
# Disassemble options
#

ifneq (,$(filter d diss d* diss*, $(MAKECMDGOALS)))


ifneq (,$(findstring .optnop, $(opts)))
objdump_nop = "sed 's/:\(\t.*\t\)/:    /g'"
endif

ifneq (,$(symbol))
objdump_disassemble = "--disassemble=$(symbol:..%=%)"
endif

endif


#
# Disassemble
#

diss d diss* d* : baz=$(bar)

diss d diss* d*: $(IMG) 
	@objdump -f $< > /dev/null 2>&1; \
	if test $$? -eq 1   ; then \
	  objdump -M $(ASM_SYNTAX) -b binary -m $(ASM_MACHINE) -D $< | "$(objdump_nop)"; \
	else \
	  if test $@ = "diss" || test $@ = "d" ; then\
	   objdump -M $(ASM_SYNTAX) -m $(ASM_MACHINE) $(objdump_disassemble) $<  | "$(objdump_nop)" ;\
	  else\
	    objdump -M $(ASM_SYNTAX) -m $(ASM_MACHINE) -D $< | "$(objdump_nop)" ; \
	 fi;\
	fi

%/diss %/d %/diss* %/d*: %
	make $(@F) IMG=$< $(filter 16 32 intel att $(opts) $(symbol), $(MAKECMDGOALS)) 

%/i16 %/16i : %
	make --quiet $</diss intel 16 $(opts) $(symbol)
%/i32 %/32i %/i: %
	make --quiet $</diss intel 32 $(opts) $(symbol)
%/a16 %/16a %/16 : %
	make --quiet $</diss att 16 $(opts) $(symbol)
%/a32 %/32a %/32 %/a: %
	make --quiet $</diss att 32 $(opts) $(symbol)

%/i16* %/16i* : %
	make --quiet $</diss* intel 16 $(opts) $(symbol)
%/i32* %/32i* %/i*: %
	make --quiet $</diss* intel 32 $(opts) $(symbol)
%/a16* %/16a* %/16* : %
	make --quiet $</diss* att 16 $(opts) $(symbol)
%/a32* %/32a* %/32* %/a*: %
	make --quiet $</diss* att 32 $(opts) $(symbol)

%/less : %
	less $(@D)

%/cat : %
	cat $(@D)

##
## Run on the emulator
##

# 
#
# %/run : %
# 	@i=$< &&\
# 	if test $${i##*.} = "img"; then\
# 	    make run-fd IMG=$<;\
# 	 else\
# 	   if test $${i##*.} = "bin"; then\
# 	     make run-bin IMG=$<;\
# 	    fi;\
# 	fi
#
# %/bin : %
# 	make run-bin IMG=$<
#
# %/fd : %
# 	make run-fd IMG=$<

%/run : %
	make run IMG=$<

run: $(IMG)
	qemu-system-i386 -drive format=raw,file=$< -net none

# These are deprecate; use %/run, instead.

run-bin: $(IMG)
	qemu-system-i386 -drive format=raw,file=$< -net none
	@echo "Shortcut run-bin is deprecated: use 'make run' instead."

run-iso: $(IMG)
	qemu-system-i386 -drive format=raw,file=$< -net none
	@echo "Shortcut run-iso is deprecated: use 'make run' instead."

run-fd : $(IMG)
	qemu-system-i386 -drive format=raw,file=$< -net none
	@echo "Shortcut run-fd is deprecated: use 'make run' instead."



# Dump contents in hexadecimal

hex raw dump: $(IMG)
	hexdump -C $<


%/hex %raw %/dump : %
	make --quiet dump IMG=$< 


# Diff-compare


MISSING_DIFF_TOOL="Can't find $(DIFF_TOOL); please edit syseg/tools/bintools.m4"

# Compare objects

objdiff bindiff : $(wordlist 2, 4, $(MAKECMDGOALS))
	if  test -z $$(which $(DIFF_TOOL)); then echo $(MISSING_DIFF_TOOL); exit 1; fi
	if test $(words $^) -lt 4 ; then\
	  bash -c "$(DIFF_TOOL) <(make $(wordlist 1,1,$^)/diss $(ASM) $(BIT)) <(make $(wordlist 2,2,$^)/diss $(ASM) $(BIT))";\
	else\
	  bash -c "$(DIFF_TOOL) <(make $(wordlist 1,1,$^)/diss $(ASM) $(BIT)) <(make $(wordlist 2,2,$^)/diss $(ASM) $(BIT)) <(make $(wordlist 3,3,$^)/diss $(ASM) $(BIT))";\
	fi

# Compare sources

srcdiff : $(wordlist 2, 4, $(MAKECMDGOALS))
	if  test -z $$(which $(DIFF_TOOL)); then echo $(MISSING_DIFF_TOOL); exit 1; fi
	if test $(words $^) -lt 3 ; then\
	  bash -c "$(DIFF_TOOL) $(wordlist 1,1,$^) $(wordlist 2,2,$^)";\
	else\
	  bash -c "$(DIFF_TOOL) $(wordlist 1,1,$^) $(wordlist 2,2,$^) $(wordlist 3,3,$^)";\
	fi

# Compare hex

hexdiff : $(wordlist 2, 4, $(MAKECMDGOALS))
	if  test -z $$(which $(DIFF_TOOL)); then echo $(MISSING_DIFF_TOOL); exit 1; fi
	if test $(words $^) -lt 4 ; then\
	  bash -c "$(DIFF_TOOL) <(make $(wordlist 1,1,$^)/hex $(ASM) $(BIT)) <(make $(wordlist 2,2,$^)/hex $(ASM) $(BIT))";\
	else\
	  bash -c "$(DIFF_TOOL) <(make $(wordlist 1,1,$^)/hex $(ASM) $(BIT)) <(make $(wordlist 2,2,$^)/hex $(ASM) $(BIT)) <(make $(wordlist 3,3,$^)/hex $(ASM) $(BIT))";\
	fi


# Compare objects and sources

diff : $(word 2, $(MAKECMDGOALS))
	@echo $(wordlist 2, 4, $(MAKECMDGOALS))
	@EXT=$(suffix $<);\
	case $$EXT in \
	.bin | .o)\
		make --quiet objdiff $(wordlist 2, 4, $(MAKECMDGOALS))\
		;;\
	.asm | .S | .s | .i | .c | .h | .hex)\
		make --quiet srcdiff $(wordlist 2, 4, $(MAKECMDGOALS))\
		;;\
	.img )\
		make --quiet hexdiff $(wordlist 2, 4, $(MAKECMDGOALS))\
		;;\
	*)\
		echo "I don't know how to compare filetype $$EXT"\
		;;\
	esac


# Choose between intel|att and 16-bit|32-bot

diffi16 di16 i16:
	make --quiet diff $(wordlist 2, 4, $(MAKECMDGOALS)) ASM=intel BIT=16

diffi32 di32 i32:
	make --quiet diff $(wordlist 2, 4, $(MAKECMDGOALS)) ASM=intel BIT=32

diffa16 da16 a16:
	make --quiet diff $(wordlist 2, 4, $(MAKECMDGOALS)) ASM=att BIT=16

diffa32 da32 a32:
	make --quiet diff $(wordlist 2, 4, $(MAKECMDGOALS)) ASM=att BIT=32

##
## Create bootable USP stick if BIOS needs it
##

%.iso : %.bin
	xorriso -as mkisofs -b $< -o $@ -isohybrid-mbr $< -no-emul-boot -boot-load-size 4 ./

%.img : %.bin
	dd if=/dev/zero of=$@ bs=1024 count=1440
	dd if=$< of=$@ seek=0 conv=notrunc



stick: $(IMG)
	@if test -z "$(DEVICE)"; then \
	echo "*** ATTENTION: make IMG=foo.bin DEVICE=/dev/X"; exit 1; fi 
	dd if=$< of=$(DEVICE)

%/stick: %
	make stick IMG=$* DEVICE=$(wordlist 2, 2, $(MAKECMDGOALS))



.PHONY: clean clean-extra intel att 16 32 diss /diss /i16 /i32 /a16 /a32



# End of Bintools.
# -------------------------------------------------------------



##
## Programs
##

# Create a FAT12 filesystem

mkfat12-beta : mkfat12-beta.o 
	gcc $< -o $@

# Creaate a FAT12 filesystem with custom bootstrap code

mkfat12 : mkfat12.o mbs.o 
	gcc $(filter %.o, $^) -o $@

# Inspect a FAT12/FAT16 BPB information

mbrinfo : mbrinfo.o
	gcc $< -o $@

fatinfo : fatinfo.o
	gcc $< -o $@

%.o : %.c
	gcc -c $< -o $@

mkfat12-beta mkfat12 mbrinfo : fat12.h

mbrinfo: fat.h

##
## Using the mkfat12-beta program
##

# Create a FAT12-formatted floppy disk image

fat12.img: | mkfat12-beta
        # Create the floppy disk information
	dd if=/dev/zero of=$@ count=2880       
        # Write the fat information
	./mkfat12-beta $@


# Create a bootable FAT12-formatted floppy disk image.
# How about using the Hello World program we developed in eg/hw?

fat12-boot.img: hw.bin | mkfat12-beta
        # Create the floppy disk image
	dd if=/dev/zero of=$@ count=2880       
        # Write the fat information
	./mkfat12-beta $@                      
        # Write the bootstrap program at the appropriate offset
	dd if=hw.bin of=$@ obs=1 conv=notrunc seek=62 

##
## Using the full-featured mkfat12 program
##

#  The program mkfat12 creates a FAT12 filesystem on a device.
#  If a file containing a bootstrap program is specified, its contents are
#  copied verbatim to the appropriate location in the device's MBR. If such
#  a program is not specified, mkfat12 uses a default bootstrap program.

mkfat12 : mkfat12.o mbs.o
	gcc mkfat12.o mbs.o -o $@

#  This is the default bootstrap program used by mkfat12.
#  The program outputs a message and offers the user the possibility of
#  replacing the media and pressing any key to reload the boot sector.
#
#  The program is written in assembly.

#  (notice -Ttext=0x7c3e = load_address + bootstrap_offset)

mbs.bin : mbs.S
	as --32 $< -o mbs.o
	ld -melf_i386 --oformat=binary -Ttext=0x7c3e -e mbs  mbs.o -o $@

#  In order to embed the program within mkfat, that's how we proceed.
#
#  We convert the binary mbr.bin into a sequence of hexadecimal values,
#  like hexdump does. Then we create a program mbs.c containting
#
#     int mbs_length =  <the length of mbr.bin> ;
#     const char mbs[]={ ... the sequence of bytes in mbr.bin, as hex values };
#

mbs.c : mbs.bin
	echo "int mbs_length = " `../../tools/bin2hex mbs.bin | wc -w` ";" > $@
	echo "const char mbs[]={" >> $@
	../../tools/bin2hex mbs.bin | sed -s 's/ [0-9a-f][0-9a-f]/,&/g' | sed -s 's/[0-9a-f][0-9a-f]/0x&/g'>> $@
	echo "};" >> $@

#  We then compile mbr.c into mbr.o and link mbr.o with mkfat12.
#  Then, in mkfat, we can access the vector mbr[] to write its contents,
#  byte by byte, into the device's MBR.

mbs.o : mbs.c
	gcc $< -c -o $@


# Create a bootable FAT12-formatted floppy disk image using mkfat12.

boot12.img: mbs.bin | mkfat12
	dd if=/dev/zero of=$@ count=2880
	./mkfat12  $@


# Create some disk-image examples and format them with
# a standard utility (mkfs, from util-linux).


fat12-mkfs.img:
	dd if=/dev/zero of=$@ count=2880
	mkfs.fat -F 12 $@

fat16-mkfs.img:
	dd if=/dev/zero of=$@ count=32768
	mkfs.fat -F 16 $@

fat32-mkfs.img:
	dd if=/dev/zero of=$@ count=131072
	mkfs.fat -F 32 $@


# Extra examples

egx-01.bin : egx-01.hex
	../../tools/hex2bin $< $@

#
# Auxiliary artifacts
#

# This is the bare-metal Hello World we've developed as part of eg/hw series.
# For illustration purpose, We may use it as a boostrap code for a bootable
# FAT-formatted disk.

hw.bin : hw.ld $(addprefix ../hw/, eg-07.o eg-07_utils.o eg-07_rt0.o)
	ld -melf_i386 -T hw.ld --orphan-handling=discard  $(addprefix ../hw/, eg-07.o eg-07_utils.o) -o $@

.PHONY: $(addprefix ../hw/, eg-07.o eg-07_utils.o eg-07_rt0.o) 
$(addprefix ../hw/, eg-07.o eg-07_utils.o eg-07_rt0.o) : 
	make -C ../hw/ $(notdir $@)


img = fat12.img fat12-boot.img
img += fat12-mkfs.img fat16-mkfs.img fat32-mkfs.img

all: $(img)

.PHONY: clean-local
clean-local :
	rm -f *.img *.bin mbs.c *.o $(bin)

clean : clean-local
