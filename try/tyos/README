#    SPDX-FileCopyrightText: 2021 Monaco F. J. <monaco@usp.br>
#   
#    SPDX-License-Identifier: GPL-3.0-or-later
#
#    This file was generated by SYSeg from a corresponding m4 script.
#    SYSeg is available at https://gitlab.com/monaco/syseg.

 TinyOS - A trivial x86 real-mode DOS-like OS
 =============================================
 


 
 Overview
 ------------------------------
 
 In this programming exercise you are invited to write a very simple DOS-like
 kernel. The program should run in x86 real-mode and implement some
 functionality as described bellow. A start-up code based on the example
 syseg/eg/bl is included as inspiration. Unless otherwise specified by the
 instructor, you are encouraged to write your own source code from the scratch,
 rather than coping the provided files. If you do need to reuse the start-up
 code, please do not simply copy the files to your repository. Rather, use the
 SYSeg export facility:

    make export

 That should create a subdirectory with the files ready for being copied.
 If you copy some of the exported files into your repository, do not forget to
 edit the heading comments in the file to fill-in your author information.

 

 Instructions
 ------------------------------

 The code examples in this directory include explanatory comments annotated
 directly in the source file comments. Those notes are complemented by the
 additional technical discussions provided in this README file.
 
 While some examples may be independent one from another, there may be also
 sequences of code snippets in which each example builds on its predecessor.
 In those cases, it may be interesting to go through the code examples in the
 same order they are introduced in the present README.
 
 For convenience, a build script (e.g. Makefile) may be provided which contains
 rules to compile, execute and inspect the contents of the source and object
 the examples are built and executed.



 Directions
 ------------------------------

 1) Build and execute boot.img under the x86 emulator (qemu).

 2) Copy the program to a USB stick and boot it with BIOS legacy mode.

 3) Implement some cool functionality in for stage2.c.

    Note: Contrary to the first stage, which is constricted by the 512-byte
    (or shorter) upper bound, the second stage can be considerably large
    (limited only by the available space in the 640K conventional memory).
    Usually, we can carefreely use a few dozen of Kbytes.

    PART I
    ------

    (a) Implement a function help() that prints a "help" message on
    	the screen.

	As a suggestion, writing directly into the video display memory
	can be accomplished with just plain C source code. On the other
	hand, you'd have to implement the usual tty behavior by hand.

    (b) Implement a shell-like command processor.

        The program should show a prompt on the screen, next to which the
	user can enter some single-world command.

	The command processor should then read the user input and proceed
	as follows.

	If the command corresponds to any built-in command, the referred
	command should be executed. Implement at least the command 'help',
	which executes the function help().

	When the command execution is complete, the program should show
	the prompt again and wait for the next command.

	If the command is not recognized, show an error message and get
	back to the prompt.

	Tips: - BIOS interrupt 16h gives access to the keyboard services.
	        See https://en.wikipedia.org/wiki/INT_16H.

    (c) Implement another command that uses some BIOS service.

    	Tips: - See https://en.wikipedia.org/wiki/BIOS_interrupt_call

	With BIOS services you can get current date, available memory etc.
	
    PART II
    -------

    (a) Write write your kernel into a FAT-23 formatted USB stick.

	Get a USB disk and use your regular OS (e.g. Linux, Windows) to format
	it with a FAT32 file system.

	Then create a Make rule in your project's Makefile that write your file
	to the MBR (Master Boot Record) of the USB stick.

	Boot your OS in the emulator and, if possible in the phyisical hardware.


    (b) Extend your command-line processor to execute external programs.

        If a command entered by the user is not recognized as a built-in
	command of your OS, then it should be interpreted as the name
	of an executable file.

	Search for the file in the boot media (the disk from which the OS
	has booted) and, if found, load the file into the RAM (byte per
	byte as is).

	Then, transfer execution to the just loaded program. When the execution
	finishes, return to the command processor and present the prompt again.

    (c) ... (to be updated).

 
  Good coding.
 


 APPENDIX A: Coding and delivering.
 ----------------------------------

 Created a directory tyos under your project repository and implement the
 programming exercise within it.

 Use the tag tyos-1a for the part I item (a) of the exercise, tyos-1b for
 part I item (b) and so on. Unless otherwise specified, you don't need to
 deliver part (a), (b) etc. separately; you can just deliver tyos-1c, for
 instance, to signal that you have completed part I items (a) and (b) already.

 
 How to deliver the exercise
 ------------------------------
  
 If you're exploring the exercise as part of a training program, chances are
 that your instructor is following the delivery workflow suggested by SYSeg. If
 that is the case, then, when you're done with the activity, you should be
 asked to upload your work into a repository managed by a version-control
 system (VCS) --- most probably Git.

 For this purpose, you must have already created your online repository in the
 recommended platform (e.g. GitHub or GitLab), cloned it, and then copied the
 exercise files into the directory of your project using the proper helper
 scripts provided by SYSeg.
 
 To deliver your programming exercise just commit your changes and push them
 into to the mainstream repository.
 

 You may commit partial changes even before completing the exercise. That may
 be a convenient way to share ideas and ask for help. Opening an issue in the
 repository with your question may be an effective way to ask for help.
 

 When you believe your work is complete, mark your final revision with a
 tag. Unless the exercise specification informs differently, use the tag
 '<dir>-done', where '<dir>' is the name of the directory containing the
 project. If you need to submit a revision after that, use the
 tag '<dir>-rev1', '<dir>-rev2' and so on.
 
 To tag your delivery:

     $ git tag <dir>-done
     $ git push origin <dir>-done

 The instructor will know you are finished with the exercise.

 Note: please, commit only source files, i.e. don't commit object files and
 other items that can be generated by the build process).
  


 APPENDIX B: SYSeg conventions.
 ----------------------------------
 


 Bintools: convenience rules for inspecting binary files
 ------------------------------------------------------------
 
 SYSeg's Bintools is a collection of Makefile rules aimed as shortcut for
 invoking binary inspection utilities. It contains handy Make rules for
 disassembling objects, comparing files, creating bootable images, invoking
 platform emulators and other facilities. Some shortcuts are ad hoc rules
 crafted under poetic license and may depart from conventional Make usage.

 CONVENTIONS
 
 As a rule of thumb, a file named

     foo.bar            contains the working implementation
     foo-beta.bar	contains working but cumbersome/inelegant implementation
     foo-alpha.bar	contains incomplete or wrong implementation

 File extensions:

   -`hex`  ASCII file containing values in hexadecimal representation;

   -`asm`  manually written assembly code in Intel ASM format;

   -`S`    manually written assembly code in AT&T Gas format;

   -`s`    assembly code in AT&T Gas format generated by the compiler (gcc);

   -`o`    object code produced by the assembler;

   -`i`    pre-processed source code generated by the pre-processor (CPP)

   -`bin`  flat-binary file generated by the linker;

   -`iso`  ISO9660 (ECMA-119) file system intended for optical disk media (CD) 

   -`ld`   linker script (ld).


 Some examples allow alternative build recipes which can be selected
 by passing the command-line variable 'ALT=<number>' to 'make'. See bellow.

 NEEDED SOFTWARE

 In order to experiment with the examples in this section, the following
 pieces of software may be needed. The list indicates the lowest versions
 against which the project has been tested. Using a more recent version should
 be ok, but it is not absolutely guaranteed that results won't exhibit minor
 variations. Feedback is always appreciated.

 If required for a particular example, it is safe to use

 - Linux         5.13.0         (any decent ditribution)
 - gcc 	     	 9.3.0	        (the GNU compiler)
 - GNU binutils  2.34		(GNU assembler, linker, disassembler etc.) 
 - nasm		 2.14.02	(NASM assembler)
 - qemu		 4.2.1		(most probably qemu-system-i386)
 - gcc-multilib  9.3.0		(to compile 32-bit code in a 64-bit platform)
 - xorriso	 1.5.2-1	(depending on your computer's BIOS)
 - hexdump	 POSIX.2	(binary editor)
 
 CONVENIENCE RULES 


 * For building and inspecting binaries, use

   make					     Build the default target.

   make foo				     Build foo.

   make diss IMG=foo 			     Disassemble foo.

   	     	     			     Optionally,

					        ASM  = intel | att  (default)
						BIT  =    16 | 32   (default)

   make dump IMG=foo			     Show the raw contents of foo.
   
   make      			             Build everything (or make all)

   make clean			             Undo make all

   make diff foo bar baz		     Show graphical diff between files

   	     	     			     ASM and BIT variables apply


  * If any example involves the manipulation of a bootable image, use
  

   make run IMG=foo	             	     Run foo in the emulator

   make stick IMG=foo DEVICE=/dev/sdX        make a bootable USB stick


   SHORTCUTS

   For further convenience, the build script offers some ad hoc shortcuts:
   

   make foo/diss | foo/d		     disassemble .text as 32-bit AT&T

   make foo/diss intel|att		     disassemble as 32-bit Intel or AT&T
   make foo/diss 16|32			     disassemble as 16-bit or 32-bit
   make foo/diss intel|att 16|32	     disassemble as Intel|AT&T 16|32 bit
   make foo/diss 16|32 intel|att	     disassemble as Intel|AT&T 16|32 bit

   make foo/i16	       			     disassemble as Intel 16-bit
   make foo/a16 | foo/16  		     disassemble as AT&T  16-bit
   make foo/a32	| foo/32 | foo/a     	     disassemble as AT&T  32-bit
   make foo/i32	         | foo/i	     disassemble as Intel 32-bit

   		   			     In all disassembly rules, a
					     trailing '*' means disassemble all
					     sections, e.g. foo/d* foo/16* ...

   make foo/hex | foo/raw | foo/dump	     show raw contents in hexadecimal

   make foo/run				     test foo (mbr) with the emulator
   make foo/fd				     test foo (floppy) with the emulator

   make diffi16 | di16 | i16 foo bar baz     make diff with ASM=intel BIT=16
   make diffi32 | di32 | i32 foo bar baz     make diff with ASM=intel BIT=32
   make diffa16 | da16 | a16 foo bar baz     make diff with ASM=att BIT=16
   make diffa32 | da32 | a32 foo bar baz     make diff with ASM=att BIT=32

   make foo/stick dev    	   	     make stick IMG=foo DEVICE=dev

   make foo/l	  			     open foo in 'less' program

  

 
